import numpy as np
from abc import ABC, abstractmethod
from typing import Dict, List, Tuple


class BaseSimulator(ABC):
    """
    Abstract base class for stochastic process simulators and optimal hedging.

    Responsibilities:
      - Store core model parameters and time grid
      - Define the interface for:
          * underlying simulation (S)
          * derivative pricing/greeks (H, dH/dS, ...)
          * PandL dynamics
          * adjoint BSDE (p, q)
          * optimality condition and control update
          * main optimization loop
    """

    def __init__(self,
                 S0: float,
                 mu: float,
                 sigma: float,
                 K: float,
                 t0: float = 0.0,
                 T: float = 1.0,
                 N: int = 252,
                 M: int = 1000,
                 seed: int = 123):
        """
        Initialize the base simulator.

        Parameters
        ----------
        S0 : float
            Initial asset price.
        mu : float
            Drift coefficient.
        sigma : float
            Diffusion volatility (standard deviation).
        K : float
            Strike price (used for the derivative).
        t0 : float, default=0.0
            Initial time.
        T : float, default=1.0
            Final time.
        N : int, default=252
            Number of time steps (used to compute dt).
        M : int, default=1000
            Number of simulated paths.
        seed : int, default=123
            Random seed for reproducibility.
        """
        self.S0 = S0
        self.mu = mu
        self.sigma = sigma
        self.K = K

        self.t0 = t0
        self.T = T
        self.N = N
        self.M = M
        self.dt = (T - t0) / N
        self.steps = int(np.round((T - t0) / self.dt))

        self.seed = seed
        if seed is not None:
            np.random.seed(seed)


    # ============================================================
    # 0. Underlying S and derivative H
    # ============================================================

    @abstractmethod
    def simulate_S(self) -> np.ndarray:
        """
        Simulate the underlying asset paths S_t.

        Returns
        -------
        S : ndarray, shape (M, steps)
            Simulated underlying paths.
        """
        raise NotImplementedError

    @abstractmethod
    def simulate_H(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray,
                                  np.ndarray, np.ndarray, np.ndarray]:
        """
        Compute (or approximate) the derivative price H_t and its greeks
        along the simulated S_path.

        Returns
        -------
        H : ndarray, shape (M, steps)
        dH_dS : ndarray, shape (M, steps)
        d2H_dSS : ndarray, shape (M, steps)
        dH_dt : ndarray, shape (M, steps)
        d2H_dt_dS : ndarray, shape (M, steps)
        d3H_dS3 : ndarray, shape (M, steps)
        """
        raise NotImplementedError

    # ============================================================
    # 1. Control initialization
    # ============================================================

    @abstractmethod
    def init_control(self, kind: str = "Delta") -> np.ndarray:
        """
        Initialize the control h.

        Parameters
        ----------
        kind : {"Delta", "zero"}
            Initialization rule.

        Returns
        -------
        h : ndarray, shape (M, steps-1)
            Initial control on each time interval [t_n, t_{n+1}).
        """
        raise NotImplementedError

    # ============================================================
    # 2. Forward P&L
    # ============================================================

    @abstractmethod
    def forward_PL(self, 
                   h: np.ndarray, 
                   L0: float = 0.0,
                   t_start: float = 0) -> np.ndarray:
        """
        Simulate the P&L L_t given the control h.

        Parameters
        ----------
        h : ndarray, shape (M, steps-1)
            Control on each interval [t_n, t_{n+1}).
        L0 : float, default=0.0
            Initial P&L.
        t_start : float, default=0
            Time index t at which Profit and Loss accumulation starts.

        Returns
        -------
        L : ndarray, shape (M, steps)
            Simulated P&L paths.
        """
        raise NotImplementedError

    # ============================================================
    # 3. Risk functional
    # ============================================================
    @staticmethod
    def risk_function(LT: np.ndarray, 
                      risk_type: str, 
                      **kwargs) -> float:
        """
        Compute the composed risk functional rho_u(L_T) from terminal Profit and Loss simulation.

        Parameters
        ----------
        LT : ndarray, shape (M,)
            Terminal Profit and Loss samples L_T^h generated by a given hedging strategy.
        risk_type : str
            Type of composed risk measure to be evaluated. Supported values are:
                - "ele"  : Expected loss with exponential utility
                - "elw"  : Expected loss with Weibull-type utility
                - "entl" : Entropic risk with linear utility
                - "ente" : Entropic risk with exponential utility
                - "entw" : Entropic risk with Weibull-type utility
                - "esl"   : Expected shortfall linear utility
        **kwargs :
            Parameters required by the chosen risk_type:
                - "a"     : risk aversion parameter (exponential utility)
                - "k"     : shape parameter (Weibull utility)
                - "gamma" : entropic risk aversion parameter
                - "beta"  : confidence level for expected shortfall

        Returns
        -------
        rho : float
            Estimation of the composed risk functional rho_u(L_T).
        """
        LT = np.asarray(LT)

        # ----------------------------
        # ele
        # ----------------------------
        if risk_type == "ele":
            a = kwargs.get("a")
            if a is None:
                raise ValueError("Parameter 'a' is required for 'ele'.")
            rho = np.mean(np.exp(-a * LT))

        # ----------------------------
        # elw
        # ----------------------------
        elif risk_type == "elw":
            k = kwargs.get("k")
            if k is None:
                raise ValueError("Parameter 'k' is required for 'elw'.")
            rho = np.mean(np.exp((-np.minimum(LT, 0.0))**k))

        # ----------------------------
        # entl
        # ----------------------------
        elif risk_type == "entl":
            gamma = kwargs.get("gamma")
            if gamma is None:
                raise ValueError("Parameter 'gamma' is required for 'entl'.")
            rho = (1.0 / gamma) * np.log(np.mean(np.exp(-gamma * LT)))

        # ----------------------------
        # ente
        # ----------------------------
        elif risk_type == "ente":
            gamma = kwargs.get("gamma")
            a = kwargs.get("a")
            if gamma is None or a is None:
                raise ValueError("Parameters 'gamma' and 'a' are required for 'ente'.")
            rho = (1.0 / gamma) * np.log(np.mean(np.exp(gamma * np.exp(-a * LT))))

        # ----------------------------
        # entw
        # ----------------------------
        elif risk_type == "entw":
            gamma = kwargs.get("gamma")
            k     = kwargs.get("k")
            if gamma is None or k is None:
                raise ValueError("Parameters 'gamma' and 'k' are required for risk_type='entw'.")
            rho = (1.0 / gamma) * np.log(np.mean(np.exp(gamma * np.exp((-np.minimum(LT, 0.0))**k)) ))

        # ----------------------------
        # esl
        # ----------------------------
        elif risk_type == "esl":
            beta = kwargs.get("beta")
            if beta is None:
                raise ValueError("Parameter 'beta' is required for risk_type='esl'.")
            LT = -LT
            alpha = np.quantile(LT, beta)
            rho = alpha + (1.0 / (1.0 - beta)) * np.mean(np.maximum(LT - alpha, 0.0))

        else:
            raise ValueError(f"Unknown risk_type '{risk_type}'.")

        return rho


    @staticmethod
    def risk_function(LT: np.ndarray, 
                      risk_type: str, 
                      **kwargs) -> float:
        """
        Compute the composed risk functional rho_u(L_T) from terminal Profit and Loss simulation.

        Parameters
        ----------
        LT : ndarray, shape (M,)
            Terminal Profit and Loss samples L_T^h generated by a given hedging strategy.
        risk_type : str
            Type of composed risk measure to be evaluated. Supported values are:
                - "ele"  : Expected loss with exponential utility
                - "elw"  : Expected loss with Weibull-type utility
                - "entl" : Entropic risk with linear utility
                - "ente" : Entropic risk with exponential utility
                - "entw" : Entropic risk with Weibull-type utility
                - "esl"   : Expected shortfall linear utility
        **kwargs :
            Parameters required by the chosen risk_type:
                - "a"     : risk aversion parameter (exponential utility)
                - "k"     : shape parameter (Weibull utility)
                - "gamma" : entropic risk aversion parameter
                - "beta"  : confidence level for expected shortfall

        Returns
        -------
        rho : float
            Estimation of the composed risk functional rho_u(L_T).
        """
        LT = np.asarray(LT)

        # ----------------------------
        # ele
        # ----------------------------
        if risk_type == "ele":
            a = kwargs.get("a")
            if a is None:
                raise ValueError("Parameter 'a' is required for 'ele'.")
            rho = np.mean(np.exp(-a * LT)) - 1

        # ----------------------------
        # elw
        # ----------------------------
        elif risk_type == "elw":
            k = kwargs.get("k")
            if k is None:
                raise ValueError("Parameter 'k' is required for 'elw'.")
            rho = np.mean(np.exp((-np.minimum(LT, 0.0))**k)) - 1

        # ----------------------------
        # entl
        # ----------------------------
        elif risk_type == "entl":
            gamma = kwargs.get("gamma")
            if gamma is None:
                raise ValueError("Parameter 'gamma' is required for 'entl'.")
            rho = (1.0 / gamma) * np.log(np.mean(np.exp(-gamma * LT)))

        # ----------------------------
        # ente
        # ----------------------------
        elif risk_type == "ente":
            gamma = kwargs.get("gamma")
            a = kwargs.get("a")
            if gamma is None or a is None:
                raise ValueError("Parameters 'gamma' and 'a' are required for 'ente'.")
            rho = (1.0 / gamma) * np.log(np.mean(np.exp(gamma * np.exp(-a * LT)))) - 1

        # ----------------------------
        # entw
        # ----------------------------
        elif risk_type == "entw":
            gamma = kwargs.get("gamma")
            k     = kwargs.get("k")
            if gamma is None or k is None:
                raise ValueError("Parameters 'gamma' and 'k' are required for risk_type='entw'.")
            rho = (1.0 / gamma) * np.log(np.mean(np.exp( gamma * np.exp((-np.minimum(LT, 0.0))**k)))) - 1

        # ----------------------------
        # esl
        # ----------------------------
        elif risk_type == "esl":
            beta = kwargs.get("beta")
            if beta is None:
                raise ValueError("Parameter 'beta' is required for risk_type='esl'.")
            LT = -LT
            alpha = np.quantile(LT, beta)
            rho = alpha + (1.0 / (1.0 - beta)) * np.mean(np.maximum(LT - alpha, 0.0))

        else:
            raise ValueError(f"Unknown risk_type '{risk_type}'.")

        return rho
    


    # ============================================================
    # 4. Terminal adjoint
    # ============================================================
    @staticmethod
    def terminal_adjoint(LT: np.ndarray, 
                         risk_type: str, 
                         **kwargs) -> np.ndarray:
        """
        Compute the terminal adjoint p_T = Upsilon(L_T) for the composed risk functional.

        Parameters
        ----------
        LT : ndarray, shape (M,)
            Terminal Profit and Loss samples L_T^h generated by a given hedging strategy.
        risk_type : str
            Type of composed risk measure. Supported values are:
                - "ele"  : Expected loss with exponential utility
                - "elw"  : Expected loss with Weibull-type utility
                - "entl" : Entropic risk with linear utility
                - "ente" : Entropic risk with exponential utility
                - "entw" : Entropic risk with Weibull-type utility
                - "esl"  : Expected shortfall with linear utility 
        **kwargs :
            Parameters required by the chosen risk_type:
                - "a"     : risk aversion parameter (exponential utility)
                - "k"     : shape parameter (Weibull utility)
                - "gamma" : entropic risk aversion parameter
                - "beta"  : confidence level for expected shortfall

        Returns
        -------
        pT : ndarray, shape (M,)
            Terminal adjoint samples p_T = Upsilon(L_T).
        """
        LT = np.asarray(LT)

        # ----------------------------
        # ele
        # ----------------------------
        if risk_type == "ele":
            a = kwargs.get("a")
            if a is None:
                raise ValueError("Parameter 'a' is required for 'ele'.")
            # Gamma(X) = -a e^{-a X}
            pT = -a * np.exp(-a * LT)

        # ----------------------------
        # elw
        # ----------------------------
        elif risk_type == "elw":
            k = kwargs.get("k")
            U = kwargs.get("U", 5.0)   
            if k is None:
                raise ValueError("Parameter 'k' is required for 'elw'.")
            u = np.minimum((-np.minimum(LT, 0.0))**k, U)
            pT = -k * (-np.minimum(LT, 0.0)) **(k - 1.0) * np.exp(u)

        # ----------------------------
        # entl
        # ----------------------------
        elif risk_type == "entl":
            gamma = kwargs.get("gamma")
            U = kwargs.get("U", 5.0)   
            if gamma is None:
                raise ValueError("Parameter 'gamma' is required for 'entl'.")
            u = np.clip(-gamma * LT, -U, U)
            pT = -np.exp(u) / np.mean(np.exp(u))

        # ----------------------------
        # ente
        # ----------------------------
        elif risk_type == "ente":
            gamma = kwargs.get("gamma")
            a = kwargs.get("a")
            U = kwargs.get("U", 5.0)   
            if gamma is None or a is None:
                raise ValueError("Parameters 'gamma' and 'a' are required for 'ente'.")
            u1 = np.clip(-a * LT, -U, U)
            u2 = np.minimum(gamma * np.exp(u1), U)
            pT = -a * np.exp(u1) * np.exp(u2)  / np.mean(np.exp(u2))

        # ----------------------------
        # entw
        # ----------------------------
        elif risk_type == "entw":
            gamma = kwargs.get("gamma")
            k = kwargs.get("k")
            U = kwargs.get("U", 5.0)
            if gamma is None or k is None:
                raise ValueError("Parameters 'gamma' and 'k' are required for risk_type='entw'.")
            u1 = np.minimum((-np.minimum(LT, 0.0) )**k, U)     
            u2 = np.minimum(gamma * np.exp(u1), U)  
            pT = -k * (-np.minimum(LT, 0.0))**(k - 1.0) * np.exp(u1) * np.exp(u2) / np.mean(np.exp(u2))

        # ----------------------------
        # esl
        # ----------------------------
        elif risk_type == "esl":
            beta = kwargs.get("beta")
            if beta is None:
                raise ValueError("Parameter 'beta' is required for risk_type='esl'.")
            # ES is applied to losses: X = -L_T
            LT = -LT
            alpha = np.quantile(LT, beta) 
            pT = (LT >= alpha).astype(float) / (1.0 - beta)

        else:
            raise ValueError(f"Unknown risk_type '{risk_type}'.")

        return pT
    
    @staticmethod
    def terminal_adjoint(LT: np.ndarray, 
                         risk_type: str, 
                         **kwargs) -> np.ndarray:
            """
            Compute the terminal adjoint p_T = Upsilon(L_T) for the composed risk functional.

            Parameters
            ----------
            LT : ndarray, shape (M,)
                Terminal Profit and Loss samples L_T^h generated by a given hedging strategy.
            risk_type : str
                Type of composed risk measure. Supported values are:
                    - "ele"  : Expected loss with exponential utility
                    - "elw"  : Expected loss with Weibull-type utility
                    - "entl" : Entropic risk with linear utility
                    - "ente" : Entropic risk with exponential utility
                    - "entw" : Entropic risk with Weibull-type utility
                    - "esl"  : Expected shortfall with linear utility 
            **kwargs :
                Parameters required by the chosen risk_type:
                    - "a"     : risk aversion parameter (exponential utility)
                    - "k"     : shape parameter (Weibull utility)
                    - "gamma" : entropic risk aversion parameter
                    - "beta"  : confidence level for expected shortfall

            Returns
            -------
            pT : ndarray, shape (M,)
                Terminal adjoint samples p_T = Upsilon(L_T).
            """
            LT = np.asarray(LT)

            # ----------------------------
            # ele
            # ----------------------------
            if risk_type == "ele":
                a = kwargs.get("a")
                if a is None:
                    raise ValueError("Parameter 'a' is required for 'ele'.")
                # Gamma(X) = -a e^{-a X}
                pT = -a * np.exp(-a * LT)

            # ----------------------------
            # elw
            # ----------------------------
            elif risk_type == "elw":
                k = kwargs.get("k")
                U = kwargs.get("U", 5.0)   
                if k is None:
                    raise ValueError("Parameter 'k' is required for 'elw'.")
                u = (-np.minimum(LT, 0.0))**k
                u = u - np.max(u)
                pT = -k * (-np.minimum(LT, 0.0)) **(k - 1.0) * np.exp(u)

            # ----------------------------
            # entl
            # ----------------------------
            elif risk_type == "entl":
                gamma = kwargs.get("gamma")
                U = kwargs.get("U", 5.0)   
                if gamma is None:
                    raise ValueError("Parameter 'gamma' is required for 'entl'.")
                u = -gamma * LT
                u = u - np.max(u)
                pT = -np.exp(u) / np.mean(np.exp(u))

            # ----------------------------
            # ente
            # ----------------------------
            elif risk_type == "ente":
                gamma = kwargs.get("gamma")
                a = kwargs.get("a")
                U = kwargs.get("U", 5.0)   
                if gamma is None or a is None:
                    raise ValueError("Parameters 'gamma' and 'a' are required for 'ente'.")
                u1 = -a * LT
                u2 = gamma * np.exp(u1)
                u2 = u2 - np.max(u2)
                pT = -a * np.exp(u1) * np.exp(u2)  / np.mean(np.exp(u2))

            # ----------------------------
            # entw
            # ----------------------------
            elif risk_type == "entw":
                gamma = kwargs.get("gamma")
                k = kwargs.get("k")
                U = kwargs.get("U", 5.0)
                if gamma is None or k is None:
                    raise ValueError("Parameters 'gamma' and 'k' are required for risk_type='entw'.")
                u1 = (-np.minimum(LT, 0.0) )**k     
                u2 = gamma * np.exp(u1)
                u2 = u2 - np.max(u2)
                pT = -k * (-np.minimum(LT, 0.0))**(k - 1.0) * np.exp(u1) * np.exp(u2) / np.mean(np.exp(u2))

            # ----------------------------
            # esl
            # ----------------------------
            elif risk_type == "esl":
                beta = kwargs.get("beta")
                if beta is None:
                    raise ValueError("Parameter 'beta' is required for risk_type='esl'.")
                # ES is applied to losses: X = -L_T
                LT = -LT
                alpha = np.quantile(LT, beta) 
                pT = (LT >= alpha).astype(float) / (1.0 - beta)

            else:
                raise ValueError(f"Unknown risk_type '{risk_type}'.")

            return pT


    # ============================================================
    # 5. Backward adjoint (p_t, q_t)
    # ============================================================

    @abstractmethod
    def backward_adjoint(self, pT: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        Solve (approximately) the backward SDE for (p_t, q_t),
        given a terminal condition p_T = pT.

        Parameters
        ----------
        pT : ndarray, shape (M,)
            Terminal condition p_T.

        Returns
        -------
        p : ndarray, shape (M, steps)
        q : ndarray, shape (M, steps-1)
        """
        raise NotImplementedError

    # ============================================================
    # 6. Optimality condition / gradient
    # ============================================================

    @abstractmethod
    def compute_gradient(self, p: np.ndarray, q: np.ndarray) -> np.ndarray:
        """
        Compute the violation of the local optimality condition
        (e.g. G_n = μ S_n p_n + σ S_n q_n for GBM).

        Parameters
        ----------
        p : ndarray, shape (M, steps)
        q : ndarray, shape (M, steps-1)

        Returns
        -------
        G : ndarray, shape (M, steps-1)
            Gradient-like quantity used to update the control.
        """
        raise NotImplementedError

    # ============================================================
    # 7. Control update
    # ============================================================
    @staticmethod
    def update_control(h: np.ndarray,
                       G: np.ndarray,
                       alpha: float = 1,
                       eps: float = 1e-12) -> np.ndarray:
        """
        Update the control using G (e.g. a gradient step).

        Parameters
        ----------
        h : ndarray, shape (M, steps-1)
            Current control.
        G : ndarray, shape (M, steps-1)
            Gradient-like term.
        alpha : float
            Step size.
        eps : float, optional
            Small constant to avoid division by zero.

        Returns
        -------
        h_new : ndarray, shape (M, steps-1)
            Updated control.
        """
        assert h.shape == G.shape
        norm_G = np.linalg.norm(G) / np.sqrt(G.size) + eps
        G_normalized = G / norm_G
        h_new = h - alpha * G_normalized

        return h_new

    # ============================================================
    # 8. Main optimization loop
    # ============================================================

    @abstractmethod
    def optimize_hedge(self,
                       risk_type: str,
                       risk_kwargs: Dict,
                       t_idx: float = 0,
                       max_iter: int = 20,
                       tol: float = 1e-4,
                       alpha: float = 1e-3,
                       verbose: bool = True) -> Tuple[np.ndarray, List[Dict]]:
        """
        Main optimization loop to compute an approximate optimal hedge h.

        Parameters
        ----------
        risk_type : str
            One of {"ele", "elw", "entl", "ente", "entw", "es"}.
        risk_kwargs : dict
            Parameters required for the chosen risk_type.
        t_idx : float, default=0
            Time index t at which P&L accumulation starts.
        max_iter : int
            Maximum number of iterations.
        tol : float
            Tolerance on E[G^2] (stopping criterion).
        alpha : float
            Step size for control updates.
        verbose : bool
            If True, print iteration logs.

        Returns
        -------
        h_opt : ndarray, shape (M, steps-1)
            Approximate optimal control.
        history : list of dict
            Iteration history (risk value, gradient norm, etc.).
        """
        raise NotImplementedError
    
    # ============================================================
    # 9. Maturity Risk computation
    # ============================================================
    def compute_MR(self,
                   risk_type: str,
                   risk_kwargs: Dict,
                   t_idx: float = 0,
                   max_iter: int = 20,
                   kind: str = "Delta",
                   tol: float = 1e-4,
                   alpha: float = 1e-3,
                   verbose: bool = True) -> Tuple[float, Dict]:
        """
        Compute the maturity risk MR(t) via two optimal hedging problems.

        The maturity risk is defined as the difference between:
            - the optimal risk on the sub-horizon [t, T], and
            - the optimal risk on the full horizon [0, T].

            MR(t) = rho_t - rho_T

        Parameters
        ----------
        t_idx : float
            Time index t at which the maturity risk is evaluated.
            Must satisfy 0 <= t_idx <= self.steps.
        risk_type : str
            Risk functional identifier (e.g. "ele", "elw", "entl", "ente", "entw", "esl").
        risk_kwargs : dict
            Parameters required by the chosen risk functional.
        kind : {"Delta", "MinVar", "zero"}
            Initialization rule.
        max_iter : int, default=20
            Maximum number of iterations in the hedge optimization.
        tol : float, default=1e-4
            Tolerance on the gradient norm (stopping criterion).
        alpha : float, default=1e-3
            Step size used in the control update.
        verbose : bool, default=True
            If True, prints optimization diagnostics.

        Returns
        -------
        MR : float
            Maturity risk at time index t_idx, defined as rho_t - rho_T.
        info : dict
            Dictionary containing:
                - "h_T"   : optimal hedge on [0, T]
                - "h_t"   : optimal hedge on [t, T]
                - "rho_T" : optimal risk on [0, T]
                - "rho_t" : optimal risk on [t, T]
        """
        raise NotImplementedError
